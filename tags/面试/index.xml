<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>面试 on Hello Friend</title><link>/tags/%E9%9D%A2%E8%AF%95/</link><description>Recent content in 面试 on Hello Friend</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Wed, 12 Apr 2023 03:37:21 +0000</lastBuildDate><atom:link href="/tags/%E9%9D%A2%E8%AF%95/index.xml" rel="self" type="application/rss+xml"/><item><title>Java面试中常问的问题</title><link>/posts/tech/java_interview_questions_230412/</link><pubDate>Wed, 12 Apr 2023 03:37:21 +0000</pubDate><guid>/posts/tech/java_interview_questions_230412/</guid><description>Java面试中常问的问题 springboot是如何实现自动装配的？ 扫描 meta_info redis 为什么快？ 分布式锁为何要结合 lua脚本来实现？redis分布式锁会有什么问题 redis 如果系统错误释放锁 和 业务执行超时释放锁，会如何？ redis 常用数据结构 kafka消息队列为何要引入组？解决了什么问题 broker, group 来说 分布式事务如何保证一致性。 mysql ABC 索引，实际查询只用到了AB， 没用到C，是什么情况? B是范围查询 Java HashMap 两次put 相同key与相同hashcode的区别。 服务发现是怎么做的</description></item><item><title>Spring缓存三级缓存机制</title><link>/posts/tech/spring_cache_230411/</link><pubDate>Tue, 11 Apr 2023 01:44:00 +0000</pubDate><guid>/posts/tech/spring_cache_230411/</guid><description>Spring三级缓存 想起之前面试被问到的一个回答的不好的基础题，“spring如何解决循环依赖的？”
因为并没有真正理解spring缓存机制和作用，所以早起看过后就忘了，现在重新复习下。
跟着GPT一步步学 Spring 三级缓存。
什么是spring三级缓存 spring三级缓存，是spring框架用于解决单例作用域Bean的循环依赖问题的一种机制。
Singleton Objects Cache 单例对象缓存： 这个缓存存储已经完全初始化的单例Bean. 这个阶段，所有依赖已经注入，所有生命周期方法已经执行完毕。当一个bean被请求时，spring首先会从这个缓存中获取Bean。 Early Singleton Objects Cache 早起打你了对象缓存：这个缓存存储已经实例化，但未完全初始化的Bean。相比 Singleton Objects Cache, 它的依赖注入和生命周期方法并没完成。 当Singleton Objects Cache中找不到Bean时候，会去这里找Bean， 以解决循环依赖。需要注意的是，如果是构造函数的注入，那么实例化阶段就要注入，此时有循环依赖是无法解决的。 Singleton Factories Cache 单例工厂缓存。这个缓存存储了创建bean的工厂对象。当在Early Singleton Objects Cache 也知道不到Bean， spring会尝试从这个缓存中获取工厂对象创建一个提前暴露的Bean实例。这个实例被放入到 Early Singleton Objects Cache 中， 以解决循环依赖的问题。 根据以上介绍我们知道，一级缓存存的是满状态的Bean， 二级缓存存的是构建好，但没初始化话好的Bean，三级缓存存的是单例工厂缓存。 无论何种方式，要装配都要先有实例才能依据实例来进行装配，所以如果是构造函数注入的循环依赖，spring三级缓存是无法解决的。
Spring Bean作用域 了解了三级缓存后，我们知道以上都是对单例bean的操作，那么来复习下spring作用域有哪些。
Singleton 单例。整个spring容器中，一个类的单例Bean实例只会被创建一次。这是Spring默认的作用域 Prototype 原型。每次请求一个Bean时候，都会创建一个新的实例。 Request 请求。每一个HTTP请求的生命周期内，一个Bean的实例只会被创建一次。这个作用于仅适用于Web应用程序。 Session 会话。在一个HTTP会话的生命周期内，一个Bean的实例只会被创建一次。这个做用户仅适用于Web应用程序。 Application 应用。 在一个ServletContext的生命周期内，一个Bean的实例只会被创建一次。这个作用域仅适用于Web应用程序。 Spring Bean生命周期 既然说到了注入，就来了解下注入时候spring做了哪些事。
Spring Bean 生命周期简化概述：
Spring容器启动 Bean 定义被读取，Spring确定Bean的依赖关系。 实例化Bean, 调用构造函数。 Setter 注入：spring 容器注入带有 @Autowired 注解的依赖项 如果实现了 BeanNameAware 、BeanFactoryAware 等接口，调用相应的方法。 如果Bean实现了BeanPostProcessor接口，调用postProcessBeforeInitialization方法 初始化Bean， 这可能包括调用 @PostConstruct 注解的方法、调用afterPropertiesSet方法(如果实现了InitializingBean接口) 或调用自定义的初始化方法 (通过@Bean(initMethod=&amp;ldquo;customInit&amp;rdquo;)指定)。 如果Bean实现了BeanPostProcessor接口，调用 postProcessAfterInitialization方法 Bean 现在已经准备好使用。 当应用程序关闭或Spring容器被销毁时，执行清理操作，包括调用@PreDestory注解的方法，调用destroy方法(如果实现了DisposableBean接口) 或调用自定义的销毁方法(通过@Bean(destroyMethod=&amp;ldquo;customDestroy&amp;rdquo;)指定) graph TD; A[Spring容器启动]--&amp;gt;B[读取Bean定义,确定Bean依赖关系] B --&amp;gt; C[实例化Bean,调用构造函数] C --&amp;gt; D[Setter注入 \ 字段注入] D --&amp;gt; E{是否实现BeanPostProcessor} E --&amp;gt;|是| F[调用postProcessBeforeInitialization] E --&amp;gt;|否| G[初始化Bean,PostConstruct注解方法,自定义初始化方法] F --&amp;gt; G G --&amp;gt;|如果实现| H[BeanPostProcessor的postProcessAfterInitialization] H --&amp;gt; I[Bean准备好了] I --&amp;gt; J[spring容器销毁,preDestroy, destory, customDestroy] J --&amp;gt; K[结束] Spring提供了哪些依赖注入方式： 构造器注入 (Constructor Injection) Setter注入 (Setter Injection) 字段注入 (Field Injection) 简单代码示例：</description></item><item><title>Java集合基础之HashMap</title><link>/posts/tech/javabase_hashmap_230410/</link><pubDate>Mon, 10 Apr 2023 08:24:53 +0000</pubDate><guid>/posts/tech/javabase_hashmap_230410/</guid><description>Java集合基础之HashMap HashMap在日常中也是使用频繁，了解它的源码很有必要。
构造方法与默认属性 public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt; implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable {} static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16 默认容量的16， ArrayList是10。
static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30; 最大容量是 1&amp;laquo;30
static final float DEFAULT_LOAD_FACTOR = 0.75f; 默认负载因子是 0.75.
static final int TREEIFY_THRESHOLD = 8; 当&amp;gt;=8时候转化为红黑树
static final int UNTREEIFY_THRESHOLD = 6; static final int MIN_TREEIFY_CAPACITY = 64; 核心内部类Node
static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; { final int hash; final K key; V value; Node&amp;lt;K,V&amp;gt; next; Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) { this.</description></item><item><title>Java基础之集合-ArrayList</title><link>/posts/tech/java_base_230409/</link><pubDate>Sun, 09 Apr 2023 02:51:02 +0000</pubDate><guid>/posts/tech/java_base_230409/</guid><description>Java基础之集合总览 - ArrayList Java集合是经常使用到的，集合类主要由Collection 和 Map 这两个接口派生。
Collection 派生出 Set，List, Queue。 Map派生HashMap, TreeMap， ConcurrentHashMap
Collection常用方法 // 返回集合中元素个数 int size(); //Returns true if this collection contains no elements. boolean isEmpty(); // 判断集合中是否存在元素o , (o==null ? e==null : o.equals(e)). boolean contains(Object o); // 添加元素 boolean add(E e); // 删除元素 boolean remove(Object o); // 清空元素 void clear(); Map常用方法 // 返回 k-v 数量 int size(); // Returns &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt; if this map contains no key-value mappings.</description></item><item><title>关于Java面试要求的思考</title><link>/posts/inbox/interview_230409/</link><pubDate>Sun, 09 Apr 2023 01:51:26 +0000</pubDate><guid>/posts/inbox/interview_230409/</guid><description>关于Java面试要求的思考 公司发布的jd, 有相对明确的要求，可以自我匹配做下参考，有针对性的准备。如下是一个高级Java的招聘任职要求：
任职要求 1、全日制统招本科及以上学历，计算机相关专业，5年以上Java开发经验； 2、基础扎实，精通Java并发编程、JVM，理解网络通信、多线程等基础框架，对各种开源开发框架如Spring boot、mybatis等有深入的应用和优化经验，掌握它的原理和机制； 3、熟悉大型分布式系统的设计与开发，熟练掌握如消息队列、ES、redis、Mysql等中间件，熟悉其原理和优化； 4、熟悉常用设计模式及开发实践，熟悉面向对象和数据结构； 5、良好的沟通能力、团队合作精神；认真负责、具有高度责任感；良好的抗压能力，优秀的学习能力； 6、有信贷、信用卡、互联网金融、贷中管理或催收系统研发经验优先； 7、高阶需要丰富的管理、规划能力； 8、英语好优先。
拆解分析 要求很常见，主要分为：学历，技术应用，经验经历，其他特定的要求等。对于学历和专业经历几乎不可选，都是固定的东西，有准备空间的是技术相关。我们也主要看技术这块。
基础扎实。
Java 基础 精通Java并发编程
多线程 JVM
Java内存模型 垃圾回收 类加载机制 理解网络通信、多线程等基础框架
Java IO 对各种开源开发框架如Spring boot, mybatis,等有深入的应用和优化经验，掌握它的原理和机制
springboot 基本概念，AOP, IOC, 代理， 循环依赖 事务传播 MyBatis 批量操作、动态SQL， 熟悉大型分布式系统的设计与开发，熟练掌握如消息队列、ES、redis、Mysql等中间件，熟悉其原理和优化；
分布式系统架构 消息队列的作用 ES使用场景和原理 Redis的使用场景和原理 MySQL 原理与SQL优化 熟悉常用的设计模式及开发实践，熟悉面向对象和数据结构；
23种设计模式，常用的几个，以及在实际项目、或spring中的应用 面向对象与数据结构 总结 以上每个环节都是需要时间和经历去学习与练习，对于有经验的对照着查漏补缺。</description></item><item><title>Interview_questions_230404</title><link>/posts/inbox/interview_questions_230404/</link><pubDate>Tue, 04 Apr 2023 17:02:47 +0800</pubDate><guid>/posts/inbox/interview_questions_230404/</guid><description>关于面试问题的一篇英文推 最近在推上看到了一名CEO写的关于面试会问的几个问题，觉得有参考意义，所以写下来. 文末附中文。
原推点这里
I’ve interviewed 1000s of people over my career. Most leaders ask the same terrible questions every time. Ask these 13 questions and I guarantee you&amp;rsquo;ll make better hiring decisions:
#1: If you were to tell a friend about our company, how would you describe what we do? Preparedness. How much do they know about your business? Mission. Vision. Values. If they are marketing/sales hires and can’t answer this, the interview is over.</description></item></channel></rss>