<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Hello Friend</title><link>/tags/java/</link><description>Recent content in Java on Hello Friend</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Fri, 14 Apr 2023 04:21:08 +0000</lastBuildDate><atom:link href="/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>JVM 常见面试题</title><link>/posts/tech/java_jvm_interview_230414/</link><pubDate>Fri, 14 Apr 2023 04:21:08 +0000</pubDate><guid>/posts/tech/java_jvm_interview_230414/</guid><description>JVM 常见面试题 我让GPT生成了几个JVM常见面试题：
以下是一些常见的 JVM（Java 虚拟机）面试题：
什么是 JVM？ JVM 的组成部分是什么？ 请解释 Java 内存模型（JMM）。 什么是类加载器（Classloader）？请解释其工作原理。 请列举 JVM 中的类加载器类型。 什么是 Just-In-Time（JIT）编译器？它的作用是什么？ 请解释 Java 堆内存和栈内存的区别。 什么是垃圾回收（Garbage Collection）？请简要描述其工作原理。 请列举并简要介绍 Java 中的垃圾回收器。 什么是分代垃圾回收策略？请解释年轻代（Young Generation）和老年代（Old Generation）的概念。 请解释 Java 中的强引用、软引用、弱引用和虚引用。 什么是 Java 堆溢出（Heap Overflow）和栈溢出（Stack Overflow）？如何处理这些问题？ 什么是逃逸分析？它在 JVM 性能优化中有什么作用？ 如何监控和调优 JVM 的性能？ 请列举 JVM 调优的一些常用参数。 请解释 Java 中的死锁、饥饿和活锁。 什么是线程安全？如何在 Java 中确保线程安全？ 请解释 Java 中的同步和异步编程。 什么是 volatile 关键字？它的作用是什么？ 请解释 Java 中的并发编程和多线程编程。 1. 什么是 JVM？ JVM 是 Java Virtual Machine 的缩写，也就是Java虚拟机。它是一个运行Java程序的跨平台容器。它的主要功能特点是：</description></item><item><title>跟着GPT学习JVM的垃圾收集器</title><link>/posts/tech/java_jvm_gc_230414/</link><pubDate>Fri, 14 Apr 2023 03:50:01 +0000</pubDate><guid>/posts/tech/java_jvm_gc_230414/</guid><description>跟着GPT学习JVM的垃圾收集器 有了GPT之后，学习热情也也高了许多，像是身边有了一个全知且没脾气的博士一样，啥问题都可以丢给他。和搜索引擎相比，GPT以问答方式直接回复，更便捷。但是也有一些错误存在，追求更精准还是要用搜索引擎。
今天来学习JDK和JVM收集器
JDK8 - JDK17 的垃圾收集器 首先问了不同JDK版本之间默认垃圾收集器的区别：
Q: Java8 - Java17 各个版本对应的默认GC是哪个?
A: 各个 Java 版本的默认垃圾收集器（GC）如下：
各个 Java 版本的默认垃圾收集器（GC）如下：
Java 8： 默认的垃圾收集器是 Parallel GC。它在年轻代（Young Generation）使用 Parallel Scavenge，而在老年代（Old Generation）使用 Parallel Old GC。 Java 9： 在 Java 9 中，默认的垃圾收集器仍然是 Parallel GC。 Java 10： Java 10 也继续使用 Parallel GC 作为默认垃圾收集器。 Java 11： 默认的垃圾收集器仍然是 Parallel GC。然而，从 Java 11 开始，ZGC 可作为实验性垃圾收集器使用。 Java 12： Java 12 同样使用 Parallel GC 作为默认垃圾收集器。此版本引入了实验性的 Shenandoah GC，但不是默认选项。 Java 13： 默认的垃圾收集器在 Java 13 中保持不变，仍然是 Parallel GC。 Java 14： Java 14 同样使用 Parallel GC 作为默认垃圾收集器。此外，这个版本中 ZGC 从实验性垃圾收集器升级为生产就绪状态。 Java 15： Java 15 保持使用 Parallel GC 作为默认垃圾收集器。 Java 16： Java 16 中默认的垃圾收集器依然是 Parallel GC。同时，G1 GC 和 ZGC 作为可选的生产就绪垃圾收集器。 Java 17： 在 Java 17（长期支持版本，LTS）中，默认垃圾收集器仍然是 Parallel GC。G1 GC、ZGC 和 Shenandoah GC 作为可选的生产就绪垃圾收集器。 请注意，虽然默认的垃圾收集器在各个版本中保持不变，但根据您的应用程序需求，您可以选择其他垃圾收集器，如 G1 GC、ZGC 或 Shenandoah GC。要更改垃圾收集器，只需在启动 Java 应用程序时设置适当的 JVM 参数。</description></item><item><title>Java面试中常问的问题</title><link>/posts/tech/java_interview_questions_230412/</link><pubDate>Wed, 12 Apr 2023 03:37:21 +0000</pubDate><guid>/posts/tech/java_interview_questions_230412/</guid><description>Java面试中常问的问题 springboot是如何实现自动装配的？ 扫描 meta_info redis 为什么快？ 分布式锁为何要结合 lua脚本来实现？redis分布式锁会有什么问题 redis 如果系统错误释放锁 和 业务执行超时释放锁，会如何？ redis 常用数据结构 kafka消息队列为何要引入组？解决了什么问题 broker, group 来说 分布式事务如何保证一致性。 mysql ABC 索引，实际查询只用到了AB， 没用到C，是什么情况? B是范围查询 Java HashMap 两次put 相同key与相同hashcode的区别。 服务发现是怎么做的</description></item><item><title>Spring缓存三级缓存机制</title><link>/posts/tech/spring_cache_230411/</link><pubDate>Tue, 11 Apr 2023 01:44:00 +0000</pubDate><guid>/posts/tech/spring_cache_230411/</guid><description>Spring三级缓存 想起之前面试被问到的一个回答的不好的基础题，“spring如何解决循环依赖的？”
因为并没有真正理解spring缓存机制和作用，所以早起看过后就忘了，现在重新复习下。
跟着GPT一步步学 Spring 三级缓存。
什么是spring三级缓存 spring三级缓存，是spring框架用于解决单例作用域Bean的循环依赖问题的一种机制。
Singleton Objects Cache 单例对象缓存： 这个缓存存储已经完全初始化的单例Bean. 这个阶段，所有依赖已经注入，所有生命周期方法已经执行完毕。当一个bean被请求时，spring首先会从这个缓存中获取Bean。 Early Singleton Objects Cache 早起打你了对象缓存：这个缓存存储已经实例化，但未完全初始化的Bean。相比 Singleton Objects Cache, 它的依赖注入和生命周期方法并没完成。 当Singleton Objects Cache中找不到Bean时候，会去这里找Bean， 以解决循环依赖。需要注意的是，如果是构造函数的注入，那么实例化阶段就要注入，此时有循环依赖是无法解决的。 Singleton Factories Cache 单例工厂缓存。这个缓存存储了创建bean的工厂对象。当在Early Singleton Objects Cache 也知道不到Bean， spring会尝试从这个缓存中获取工厂对象创建一个提前暴露的Bean实例。这个实例被放入到 Early Singleton Objects Cache 中， 以解决循环依赖的问题。 根据以上介绍我们知道，一级缓存存的是满状态的Bean， 二级缓存存的是构建好，但没初始化话好的Bean，三级缓存存的是单例工厂缓存。 无论何种方式，要装配都要先有实例才能依据实例来进行装配，所以如果是构造函数注入的循环依赖，spring三级缓存是无法解决的。
Spring Bean作用域 了解了三级缓存后，我们知道以上都是对单例bean的操作，那么来复习下spring作用域有哪些。
Singleton 单例。整个spring容器中，一个类的单例Bean实例只会被创建一次。这是Spring默认的作用域 Prototype 原型。每次请求一个Bean时候，都会创建一个新的实例。 Request 请求。每一个HTTP请求的生命周期内，一个Bean的实例只会被创建一次。这个作用于仅适用于Web应用程序。 Session 会话。在一个HTTP会话的生命周期内，一个Bean的实例只会被创建一次。这个做用户仅适用于Web应用程序。 Application 应用。 在一个ServletContext的生命周期内，一个Bean的实例只会被创建一次。这个作用域仅适用于Web应用程序。 Spring Bean生命周期 既然说到了注入，就来了解下注入时候spring做了哪些事。
Spring Bean 生命周期简化概述：
Spring容器启动 Bean 定义被读取，Spring确定Bean的依赖关系。 实例化Bean, 调用构造函数。 Setter 注入：spring 容器注入带有 @Autowired 注解的依赖项 如果实现了 BeanNameAware 、BeanFactoryAware 等接口，调用相应的方法。 如果Bean实现了BeanPostProcessor接口，调用postProcessBeforeInitialization方法 初始化Bean， 这可能包括调用 @PostConstruct 注解的方法、调用afterPropertiesSet方法(如果实现了InitializingBean接口) 或调用自定义的初始化方法 (通过@Bean(initMethod=&amp;ldquo;customInit&amp;rdquo;)指定)。 如果Bean实现了BeanPostProcessor接口，调用 postProcessAfterInitialization方法 Bean 现在已经准备好使用。 当应用程序关闭或Spring容器被销毁时，执行清理操作，包括调用@PreDestory注解的方法，调用destroy方法(如果实现了DisposableBean接口) 或调用自定义的销毁方法(通过@Bean(destroyMethod=&amp;ldquo;customDestroy&amp;rdquo;)指定) graph TD; A[Spring容器启动]--&amp;gt;B[读取Bean定义,确定Bean依赖关系] B --&amp;gt; C[实例化Bean,调用构造函数] C --&amp;gt; D[Setter注入 \ 字段注入] D --&amp;gt; E{是否实现BeanPostProcessor} E --&amp;gt;|是| F[调用postProcessBeforeInitialization] E --&amp;gt;|否| G[初始化Bean,PostConstruct注解方法,自定义初始化方法] F --&amp;gt; G G --&amp;gt;|如果实现| H[BeanPostProcessor的postProcessAfterInitialization] H --&amp;gt; I[Bean准备好了] I --&amp;gt; J[spring容器销毁,preDestroy, destory, customDestroy] J --&amp;gt; K[结束] Spring提供了哪些依赖注入方式： 构造器注入 (Constructor Injection) Setter注入 (Setter Injection) 字段注入 (Field Injection) 简单代码示例：</description></item><item><title>Java集合基础之HashMap</title><link>/posts/tech/javabase_hashmap_230410/</link><pubDate>Mon, 10 Apr 2023 08:24:53 +0000</pubDate><guid>/posts/tech/javabase_hashmap_230410/</guid><description>Java集合基础之HashMap HashMap在日常中也是使用频繁，了解它的源码很有必要。
构造方法与默认属性 public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt; implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable {} static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16 默认容量的16， ArrayList是10。
static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30; 最大容量是 1&amp;laquo;30
static final float DEFAULT_LOAD_FACTOR = 0.75f; 默认负载因子是 0.75.
static final int TREEIFY_THRESHOLD = 8; 当&amp;gt;=8时候转化为红黑树
static final int UNTREEIFY_THRESHOLD = 6; static final int MIN_TREEIFY_CAPACITY = 64; 核心内部类Node
static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; { final int hash; final K key; V value; Node&amp;lt;K,V&amp;gt; next; Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) { this.</description></item><item><title>Java基础之集合-ArrayList</title><link>/posts/tech/javabase_list_230409/</link><pubDate>Sun, 09 Apr 2023 02:51:02 +0000</pubDate><guid>/posts/tech/javabase_list_230409/</guid><description>Java基础之集合总览 - ArrayList Java集合是经常使用到的，集合类主要由Collection 和 Map 这两个接口派生。
Collection 派生出 Set，List, Queue。 Map派生HashMap, TreeMap， ConcurrentHashMap
Collection常用方法 // 返回集合中元素个数 int size(); //Returns true if this collection contains no elements. boolean isEmpty(); // 判断集合中是否存在元素o , (o==null ? e==null : o.equals(e)). boolean contains(Object o); // 添加元素 boolean add(E e); // 删除元素 boolean remove(Object o); // 清空元素 void clear(); Map常用方法 // 返回 k-v 数量 int size(); // Returns &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt; if this map contains no key-value mappings.</description></item><item><title>关于Java面试要求的思考</title><link>/posts/inbox/interview_230409/</link><pubDate>Sun, 09 Apr 2023 01:51:26 +0000</pubDate><guid>/posts/inbox/interview_230409/</guid><description>关于Java面试要求的思考 公司发布的jd, 有相对明确的要求，可以自我匹配做下参考，有针对性的准备。如下是一个高级Java的招聘任职要求：
任职要求 1、全日制统招本科及以上学历，计算机相关专业，5年以上Java开发经验； 2、基础扎实，精通Java并发编程、JVM，理解网络通信、多线程等基础框架，对各种开源开发框架如Spring boot、mybatis等有深入的应用和优化经验，掌握它的原理和机制； 3、熟悉大型分布式系统的设计与开发，熟练掌握如消息队列、ES、redis、Mysql等中间件，熟悉其原理和优化； 4、熟悉常用设计模式及开发实践，熟悉面向对象和数据结构； 5、良好的沟通能力、团队合作精神；认真负责、具有高度责任感；良好的抗压能力，优秀的学习能力； 6、有信贷、信用卡、互联网金融、贷中管理或催收系统研发经验优先； 7、高阶需要丰富的管理、规划能力； 8、英语好优先。
拆解分析 要求很常见，主要分为：学历，技术应用，经验经历，其他特定的要求等。对于学历和专业经历几乎不可选，都是固定的东西，有准备空间的是技术相关。我们也主要看技术这块。
基础扎实。
Java 基础 精通Java并发编程
多线程 JVM
Java内存模型 垃圾回收 类加载机制 理解网络通信、多线程等基础框架
Java IO 对各种开源开发框架如Spring boot, mybatis,等有深入的应用和优化经验，掌握它的原理和机制
springboot 基本概念，AOP, IOC, 代理， 循环依赖 事务传播 MyBatis 批量操作、动态SQL， 熟悉大型分布式系统的设计与开发，熟练掌握如消息队列、ES、redis、Mysql等中间件，熟悉其原理和优化；
分布式系统架构 消息队列的作用 ES使用场景和原理 Redis的使用场景和原理 MySQL 原理与SQL优化 熟悉常用的设计模式及开发实践，熟悉面向对象和数据结构；
23种设计模式，常用的几个，以及在实际项目、或spring中的应用 面向对象与数据结构 总结 以上每个环节都是需要时间和经历去学习与练习，对于有经验的对照着查漏补缺。</description></item></channel></rss>