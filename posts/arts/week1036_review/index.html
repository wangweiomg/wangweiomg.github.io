<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="ARTS - Review 补2019.3.13 Generating Unique Id in Distributed Environment in high Scale:
大规模生成分布式系统的唯一ID
Recently I was working on a project which requires unique id in a distributed environment which we used as a primary key to store in databases. In a single server, it is easy to generate unique id like *** Oracle *** uses *sequence(increment counter for next id )* in SQL auto increment primary key column in tables."><meta name=keywords content=",arts"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=/posts/arts/week1036_review/><title>Week1036_review :: Hello Friend — A coder's Homepage</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css integrity="sha512-Cv93isQdFwaKBV+Z4X8kaVBYWHST58Xb/jVOcV9aRsGSArZsgAnFIhMpDoMDcFNoUtday1hdjn0nGp3+KZyyFw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/main.2a064c455b0ecbd6b1481b3bf9df2441e95838691022f40a5338c2cb1244f075.css integrity="sha256-KgZMRVsOy9axSBs7+d8kQelYOGkQIvQKUzjCyxJE8HU="><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Week1036_review"><meta itemprop=description content="ARTS - Review 补2019.3.13 Generating Unique Id in Distributed Environment in high Scale:
大规模生成分布式系统的唯一ID
Recently I was working on a project which requires unique id in a distributed environment which we used as a primary key to store in databases. In a single server, it is easy to generate unique id like *** Oracle *** uses *sequence(increment counter for next id )* in SQL auto increment primary key column in tables."><meta itemprop=datePublished content="2023-03-31T15:45:46+00:00"><meta itemprop=dateModified content="2023-03-31T15:45:46+00:00"><meta itemprop=wordCount content="546"><meta itemprop=keywords content="arts,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Week1036_review"><meta name=twitter:description content="ARTS - Review 补2019.3.13 Generating Unique Id in Distributed Environment in high Scale:
大规模生成分布式系统的唯一ID
Recently I was working on a project which requires unique id in a distributed environment which we used as a primary key to store in databases. In a single server, it is easy to generate unique id like *** Oracle *** uses *sequence(increment counter for next id )* in SQL auto increment primary key column in tables."><meta property="og:title" content="Week1036_review"><meta property="og:description" content="ARTS - Review 补2019.3.13 Generating Unique Id in Distributed Environment in high Scale:
大规模生成分布式系统的唯一ID
Recently I was working on a project which requires unique id in a distributed environment which we used as a primary key to store in databases. In a single server, it is easy to generate unique id like *** Oracle *** uses *sequence(increment counter for next id )* in SQL auto increment primary key column in tables."><meta property="og:type" content="article"><meta property="og:url" content="/posts/arts/week1036_review/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-31T15:45:46+00:00"><meta property="article:modified_time" content="2023-03-31T15:45:46+00:00"><meta property="og:site_name" content="Hello Friend "><meta property="article:published_time" content="2023-03-31 15:45:46 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>hello world...</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li><li><a href=/categorys>Category</a></li><li><a href=/series>Series</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 minutes</p></div><article><h1 class=post-title><a href=/posts/arts/week1036_review/>Week1036_review</a></h1><div class=post-content><h2 id=arts---review-补2019313>ARTS - Review 补2019.3.13</h2><p><a href=https://medium.com/@sauravomar01/generating-unique-id-in-distributed-environment-in-high-scale-88f83240db57>Generating Unique Id in Distributed Environment in high Scale:</a></p><p>大规模生成分布式系统的唯一ID</p><blockquote><p>Recently I was working on a project which requires unique id in a distributed environment which we used as a <strong>primary</strong> key to store in databases. In a single server, it is easy to generate unique id like *** Oracle *** uses *<strong>sequence(increment counter for next id )*</strong> <em>in SQL auto increment primary key column in tables.</em></p></blockquote><p>最近我工作在一个需要生成唯一ID作为主键存在数据库的分布式环境。在一个单机环境，很容易生成唯一ID，像 ORACLE 使用 sequence(增长生成下一个ID) 在SQL表中自增主键列。</p><blockquote><p>In <em>SQL</em> we can do it while creation of the table.</p></blockquote><p>在SQL中，我们创建表时候这样做：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> example (
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>primary</span> <span style=color:#66d9ef>key</span> AUTOINCREMENT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><blockquote><p>In <em>Oracle,</em> we use sequence while inserting in table.</p></blockquote><p>在Oracle ， 我们使用序列来插入表。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> SEQUENCE seq_example
</span></span><span style=display:flex><span><span style=color:#66d9ef>MINVALUE</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>START</span> <span style=color:#66d9ef>WITH</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>INCREMENT</span> <span style=color:#66d9ef>BY</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CACHE</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> example(primary_key) <span style=color:#66d9ef>VALUES</span>(seq_example.NEXTVAL);
</span></span></code></pre></div><blockquote><p>In a single server, it&rsquo;s pretty easy to generate a primary key, <em>In a distributed environment, it becomes a problem because key should be unique in all the nodes</em>. Let’s see how can we do it in a distributed environment.</p><p>There are a couple of approaches which has pros and cons both so let’s go through one by one.</p></blockquote><p>在单服务器上，很容易就生成一个主键，在一个分布式环境，因为要保证键在所有节点唯一，就成了问题。在分布式环境该如何做呢？</p><p>这有两种方法各有利弊，我们一个个看。</p><h3 id=database-ticket-servers>Database Ticket Servers:</h3><blockquote><p>These are the Centralized Auto increment servers which response with unique ids when requested from the nodes. The problem with these kinds of nodes is a single point of failure because all the nodes are dependent on this server if it fails then all nodes will not able to process further.</p></blockquote><p>这些是集中式自动增量服务器，当节点请求时会返回唯一ID作响应。问题是当多个这种节点都依赖这台服务器，如果它出现故障，所有的节点都将出现问题。</p><p><img src=https://miro.medium.com/max/1290/1*mu6PaFArn_O2Gl4thJa7bQ.png alt></p><h3 id=uuid>UUID</h3><blockquote><p><a href=https://en.wikipedia.org/wiki/Universally_unique_identifier>UUIDs</a> are 128-bit hexadecimal numbers that are globally unique. The chances of the same UUID getting generated twice is a negligible or very very less probability for collisions <em>UUID contains a reference to the network address of the host that generated the UUID, a timestamp (a record of the precise time of a transaction), and some randomly generated component.</em></p></blockquote><p>UUID 是128位全局唯一散列数字。两次生成同样的UUID机会是非常低的或者非常小的通途概率，UUID包含生成UUID的主机网络地址引用，一个时间戳(一次事务的时间片)，和一些随机组件。</p><p>According to <a href=https://en.wikipedia.org/wiki/Universally_unique_identifier#Random_UUID_probability_of_duplicates>Wikipedia</a>, regarding the probability of duplicates in random UUIDs:</p><blockquote><p>Only after generating 1 billion UUIDs every second for the next 100 years, the probability of creating just one duplicate would be about 50%. Or, to put it another way, the probability of one duplicate would be about 50% if every person on earth owned 600 million UUIDs.</p></blockquote><p>根据 Wikipedia ， 解释随机UUID可能重复的情况：</p><p>接下来100年每秒生成10亿UUID，生成一个重复UUID的概率约50%.或者，换句话说，地球上每人都拥有600百万UUIDS， 才有50% 几率出现一次重复。</p><ul><li>UUID’ s does not require coordination between different nodes and can be generated independently.</li></ul><p>UUID不要求不同节点的条件，可以独立生成。</p><blockquote><p>But the problem with UUID is very big in size and does not index well so while indexing it will take more size which effects query performance.</p></blockquote><p>但是UUID的问题也很大，就是尺寸很大，不能友好索引，以便提高查询性能。</p><h3 id=twitter-snowflake>Twitter Snowflake</h3><blockquote><p><a href=https://github.com/twitter/snowflake/tree/snowflake-2010>Twitter snowflake</a> is a dedicated network service for generating 64-bit unique IDs at high scale with some simple guarantees.</p></blockquote><p>Twitter Snowflake 是一个利用几个简单保证依赖网络服务来生成64位唯一ID的高性能方法。</p><blockquote><p>The IDs are made up of the following components:</p></blockquote><ul><li><em>Epoch timestamp in millisecond precision</em> — 41 bits (gives us 69 years with a custom epoch)</li><li><em>Machine id</em> — 10 bits (gives us up to 1024 machines)</li><li><em>Sequence number</em> — 12 bits (A local counter per machine that rolls over every 4096)</li><li>The extra 1 bit is reserved for future purposes.</li></ul><p>ID由以下组件组成：</p><ul><li>精确到毫秒的时间戳 &mdash; 41 位(可以使用69年）</li><li>机器ID &mdash; 10位(可以使用1024个机器)</li><li>序列号 &mdash; 12位(每台机器本地序列号，每个都到4096)</li><li>额外1位为未来保留</li></ul><blockquote><p><em>So the id which is generated by this is 64bit which solves the problems of size and latency issues but also introduces one problem for maintaining extra servers.</em></p><p>That’s it</p><p>Happy Learning.</p></blockquote><p>所以64位生成的ID解决了大小和延时问题，但是也引入了额外机器的问题。</p><p>以上。</p><p>学习快乐。</p></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=/tags/arts/>arts</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>546 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2023-03-31 15:45</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/arts/week1036_algorithm/><span class=button__icon>←</span>
<span class=button__text>Week1036_algorithm</span></a></span>
<span class="button next"><a href=/posts/arts/week1036_share/><span class=button__text>Week1036_share</span>
<span class=button__icon>→</span></a></span></div></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.c90b8161416b87c69a8e02683b54ddd6edb90aea699648bf655e6cbc45b419b8e465d196e715772463dba35a6faf5decb2eb247480d38680484d54645b434570.js integrity="sha512-yQuBYUFrh8aajgJoO1Td1u25Cupplki/ZV5svEW0GbjkZdGW5xV3JGPbo1pvr13ssuskdIDThoBITVRkW0NFcA=="></script></body></html>