<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="ARTS - Tip 补 2019.2.6 线程池的getTask()方法 线程池持有线程不退出的思路 学线程池，都知道它的好处就是减少了频繁创建、销毁线程的开销，从而提高效率的，那么到底是怎么实现这个机制的呢？
我们自己设想下，线程的声明周期就是创建、就绪、运行、销毁。如果线程一直在运行状态并且可以接收其他任务，那么其实就相当于是避开了频繁创建、销毁的开销。那么，线程池也是这么个思路。
先看代码 runWorker, 我们知道runWorker其实就是相当于线程的run方法， 同理addWorker 可以看做是创建线程。
runWorker final void runWorker(Worker w) { Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try { /** 注意这个while循环， task为空时候就调用了getTask()方法， * 这个getTask()方法其实就充当了获取待执行任务的功能 * 还有个重要点是看这个while循环里的最后，重置 task = null, * 这时候就相当于调用getTask()获取任务了,接下来我们看getTask() */ while (task != null || (task = getTask()) != null) { w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted."><meta name=keywords content=",arts"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=/posts/arts/week1031_tip/><title>Week1031_tip :: Hello Friend — A coder's Homepage</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css integrity="sha512-Cv93isQdFwaKBV+Z4X8kaVBYWHST58Xb/jVOcV9aRsGSArZsgAnFIhMpDoMDcFNoUtday1hdjn0nGp3+KZyyFw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/main.2a064c455b0ecbd6b1481b3bf9df2441e95838691022f40a5338c2cb1244f075.css integrity="sha256-KgZMRVsOy9axSBs7+d8kQelYOGkQIvQKUzjCyxJE8HU="><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Week1031_tip"><meta itemprop=description content="ARTS - Tip 补 2019.2.6 线程池的getTask()方法 线程池持有线程不退出的思路 学线程池，都知道它的好处就是减少了频繁创建、销毁线程的开销，从而提高效率的，那么到底是怎么实现这个机制的呢？
我们自己设想下，线程的声明周期就是创建、就绪、运行、销毁。如果线程一直在运行状态并且可以接收其他任务，那么其实就相当于是避开了频繁创建、销毁的开销。那么，线程池也是这么个思路。
先看代码 runWorker, 我们知道runWorker其实就是相当于线程的run方法， 同理addWorker 可以看做是创建线程。
runWorker final void runWorker(Worker w) { Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try { /** 注意这个while循环， task为空时候就调用了getTask()方法， * 这个getTask()方法其实就充当了获取待执行任务的功能 * 还有个重要点是看这个while循环里的最后，重置 task = null, * 这时候就相当于调用getTask()获取任务了,接下来我们看getTask() */ while (task != null || (task = getTask()) != null) { w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted."><meta itemprop=datePublished content="2023-03-31T15:45:44+00:00"><meta itemprop=dateModified content="2023-03-31T15:45:44+00:00"><meta itemprop=wordCount content="591"><meta itemprop=keywords content="arts,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Week1031_tip"><meta name=twitter:description content="ARTS - Tip 补 2019.2.6 线程池的getTask()方法 线程池持有线程不退出的思路 学线程池，都知道它的好处就是减少了频繁创建、销毁线程的开销，从而提高效率的，那么到底是怎么实现这个机制的呢？
我们自己设想下，线程的声明周期就是创建、就绪、运行、销毁。如果线程一直在运行状态并且可以接收其他任务，那么其实就相当于是避开了频繁创建、销毁的开销。那么，线程池也是这么个思路。
先看代码 runWorker, 我们知道runWorker其实就是相当于线程的run方法， 同理addWorker 可以看做是创建线程。
runWorker final void runWorker(Worker w) { Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try { /** 注意这个while循环， task为空时候就调用了getTask()方法， * 这个getTask()方法其实就充当了获取待执行任务的功能 * 还有个重要点是看这个while循环里的最后，重置 task = null, * 这时候就相当于调用getTask()获取任务了,接下来我们看getTask() */ while (task != null || (task = getTask()) != null) { w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted."><meta property="og:title" content="Week1031_tip"><meta property="og:description" content="ARTS - Tip 补 2019.2.6 线程池的getTask()方法 线程池持有线程不退出的思路 学线程池，都知道它的好处就是减少了频繁创建、销毁线程的开销，从而提高效率的，那么到底是怎么实现这个机制的呢？
我们自己设想下，线程的声明周期就是创建、就绪、运行、销毁。如果线程一直在运行状态并且可以接收其他任务，那么其实就相当于是避开了频繁创建、销毁的开销。那么，线程池也是这么个思路。
先看代码 runWorker, 我们知道runWorker其实就是相当于线程的run方法， 同理addWorker 可以看做是创建线程。
runWorker final void runWorker(Worker w) { Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try { /** 注意这个while循环， task为空时候就调用了getTask()方法， * 这个getTask()方法其实就充当了获取待执行任务的功能 * 还有个重要点是看这个while循环里的最后，重置 task = null, * 这时候就相当于调用getTask()获取任务了,接下来我们看getTask() */ while (task != null || (task = getTask()) != null) { w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted."><meta property="og:type" content="article"><meta property="og:url" content="/posts/arts/week1031_tip/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-31T15:45:44+00:00"><meta property="article:modified_time" content="2023-03-31T15:45:44+00:00"><meta property="og:site_name" content="Hello Friend "><meta property="article:published_time" content="2023-03-31 15:45:44 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>hello world...</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li><li><a href=/categorys>Category</a></li><li><a href=/series>Series</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 minutes</p></div><article><h1 class=post-title><a href=/posts/arts/week1031_tip/>Week1031_tip</a></h1><div class=post-content><h2 id=arts---tip-补-201926>ARTS - Tip 补 2019.2.6</h2><h2 id=线程池的gettask方法>线程池的getTask()方法</h2><h4 id=线程池持有线程不退出的思路>线程池持有线程不退出的思路</h4><p>学线程池，都知道它的好处就是减少了频繁创建、销毁线程的开销，从而提高效率的，那么到底是怎么实现这个机制的呢？</p><p>我们自己设想下，线程的声明周期就是创建、就绪、运行、销毁。如果线程一直在运行状态并且可以接收其他任务，那么其实就相当于是避开了频繁创建、销毁的开销。那么，线程池也是这么个思路。</p><p>先看代码 runWorker, 我们知道runWorker其实就是相当于线程的run方法， 同理addWorker 可以看做是创建线程。</p><h4 id=runworker>runWorker</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>runWorker</span><span style=color:#f92672>(</span>Worker w<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Thread wt <span style=color:#f92672>=</span> Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        Runnable task <span style=color:#f92672>=</span> w<span style=color:#f92672>.</span><span style=color:#a6e22e>firstTask</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        w<span style=color:#f92672>.</span><span style=color:#a6e22e>firstTask</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        w<span style=color:#f92672>.</span><span style=color:#a6e22e>unlock</span><span style=color:#f92672>();</span> <span style=color:#75715e>// allow interrupts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>boolean</span> completedAbruptly <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        		<span style=color:#75715e>/** 注意这个while循环， task为空时候就调用了getTask()方法，
</span></span></span><span style=display:flex><span><span style=color:#75715e>          	* 这个getTask()方法其实就充当了获取待执行任务的功能
</span></span></span><span style=display:flex><span><span style=color:#75715e>          	* 还有个重要点是看这个while循环里的最后，重置 task = null, 
</span></span></span><span style=display:flex><span><span style=color:#75715e>          	* 这时候就相当于调用getTask()获取任务了,接下来我们看getTask()
</span></span></span><span style=display:flex><span><span style=color:#75715e>          	*/</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>task <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> <span style=color:#f92672>(</span>task <span style=color:#f92672>=</span> getTask<span style=color:#f92672>())</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                w<span style=color:#f92672>.</span><span style=color:#a6e22e>lock</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If pool is stopping, ensure thread is interrupted;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// if not, ensure thread is not interrupted.  This
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// requires a recheck in second case to deal with
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// shutdownNow race while clearing interrupt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>runStateAtLeast<span style=color:#f92672>(</span>ctl<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(),</span> STOP<span style=color:#f92672>)</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                     <span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>interrupted</span><span style=color:#f92672>()</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                      runStateAtLeast<span style=color:#f92672>(</span>ctl<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(),</span> STOP<span style=color:#f92672>)))</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>!</span>wt<span style=color:#f92672>.</span><span style=color:#a6e22e>isInterrupted</span><span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>                    wt<span style=color:#f92672>.</span><span style=color:#a6e22e>interrupt</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    beforeExecute<span style=color:#f92672>(</span>wt<span style=color:#f92672>,</span> task<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    Throwable thrown <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        task<span style=color:#f92672>.</span><span style=color:#a6e22e>run</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>RuntimeException x<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        thrown <span style=color:#f92672>=</span> x<span style=color:#f92672>;</span> <span style=color:#66d9ef>throw</span> x<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Error x<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        thrown <span style=color:#f92672>=</span> x<span style=color:#f92672>;</span> <span style=color:#66d9ef>throw</span> x<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable x<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        thrown <span style=color:#f92672>=</span> x<span style=color:#f92672>;</span> <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error<span style=color:#f92672>(</span>x<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        afterExecute<span style=color:#f92672>(</span>task<span style=color:#f92672>,</span> thrown<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                  	<span style=color:#75715e>// 这里重置了task 为 null，循环继续走task = getTask()的条件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    task <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    w<span style=color:#f92672>.</span><span style=color:#a6e22e>completedTasks</span><span style=color:#f92672>++;</span>
</span></span><span style=display:flex><span>                    w<span style=color:#f92672>.</span><span style=color:#a6e22e>unlock</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            completedAbruptly <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            processWorkerExit<span style=color:#f92672>(</span>w<span style=color:#f92672>,</span> completedAbruptly<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=gettask方法>getTask()方法</h4><p>我们看源码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> Runnable <span style=color:#a6e22e>getTask</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> timedOut <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span> <span style=color:#75715e>// Did the last poll() time out?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(;;)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> ctl<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> rs <span style=color:#f92672>=</span> runStateOf<span style=color:#f92672>(</span>c<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Check if queue empty only if necessary.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>rs <span style=color:#f92672>&gt;=</span> SHUTDOWN <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>(</span>rs <span style=color:#f92672>&gt;=</span> STOP <span style=color:#f92672>||</span> workQueue<span style=color:#f92672>.</span><span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>()))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                decrementWorkerCount<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> wc <span style=color:#f92672>=</span> workerCountOf<span style=color:#f92672>(</span>c<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Are workers subject to culling?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          	<span style=color:#75715e>// 如果设置了核心线程超时退出 或者线程数大于核心线程大小，timed 就是true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>boolean</span> timed <span style=color:#f92672>=</span> allowCoreThreadTimeOut <span style=color:#f92672>||</span> wc <span style=color:#f92672>&gt;</span> corePoolSize<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>wc <span style=color:#f92672>&gt;</span> maximumPoolSize <span style=color:#f92672>||</span> <span style=color:#f92672>(</span>timed <span style=color:#f92672>&amp;&amp;</span> timedOut<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>(</span>wc <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> workQueue<span style=color:#f92672>.</span><span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>()))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>compareAndDecrementWorkerCount<span style=color:#f92672>(</span>c<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>               <span style=color:#75715e>/* 最重要的部分看这里,这做了一个判断就是 
</span></span></span><span style=display:flex><span><span style=color:#75715e>               * 1. timed == true, 走 workQueue.pool() 方法，
</span></span></span><span style=display:flex><span><span style=color:#75715e>               * 2. timed == false, 走 workQueue.task() 方法
</span></span></span><span style=display:flex><span><span style=color:#75715e>               */</span>
</span></span><span style=display:flex><span>                Runnable r <span style=color:#f92672>=</span> timed <span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>                    workQueue<span style=color:#f92672>.</span><span style=color:#a6e22e>poll</span><span style=color:#f92672>(</span>keepAliveTime<span style=color:#f92672>,</span> TimeUnit<span style=color:#f92672>.</span><span style=color:#a6e22e>NANOSECONDS</span><span style=color:#f92672>)</span> <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>                    workQueue<span style=color:#f92672>.</span><span style=color:#a6e22e>take</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>r <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> r<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                timedOut <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InterruptedException retry<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                timedOut <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>以上代码我们得到结果：</p><ol><li>timed== true 其实就是非核心线程处理和设置了核心线程超时的核心线程处理， 走poll()方法</li><li>timed == false 其实就是核心线程处理， 走 take() 方法</li></ol><p>所以实际上核心线程和非核心线程的区别(设置了超时时间的其实就是当做非核心线程处理了) 就是获取阻塞队列中方式不一样的区别了。</p><p>pool 取得队列中元素，没有就返回null， take没有就阻塞，不返回，根据这个特性，我们就发现了在runWorker里的getTask() 方法在队列为空时候就会被一直被阻塞，也就是实现了runWorker卡在那不退出的情况，也就是线程一直处在 running 的状态，等到取得新的任务，线程继续执行。</p><h4 id=简单总结>简单总结</h4><p>线程池实现方式：</p><ol><li><p>Execute 方法提交任务</p></li><li><p>addWorker 相当于线程创建，并调用了start方法，这相当于创建了一大堆线程，</p></li><li><p>每个线程执行自己的 runWorker() 方法，runWorker方法本质就是死循环从队列中取任务，当都取不到任务时候，就相当于队列为空，非核心线程获取到null 任务，核心线程获取不到任务一直被阻塞，</p></li><li><p>非核心线程继续走完runWorker() 方法，线程结束退出。</p></li></ol><h4 id=poll-和take>poll 和take</h4><p>这里说下poll和take的不同，这里看下LinkedBlockingQueue的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> E <span style=color:#a6e22e>poll</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> timeout<span style=color:#f92672>,</span> TimeUnit unit<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        E x <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> nanos <span style=color:#f92672>=</span> unit<span style=color:#f92672>.</span><span style=color:#a6e22e>toNanos</span><span style=color:#f92672>(</span>timeout<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> AtomicInteger count <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>count</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> ReentrantLock takeLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>takeLock</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        takeLock<span style=color:#f92672>.</span><span style=color:#a6e22e>lockInterruptibly</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        	<span style=color:#75715e>// 当取不到元素时候，就延迟 返回null
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>count<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>()</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>nanos <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                nanos <span style=color:#f92672>=</span> notEmpty<span style=color:#f92672>.</span><span style=color:#a6e22e>awaitNanos</span><span style=color:#f92672>(</span>nanos<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            x <span style=color:#f92672>=</span> dequeue<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            c <span style=color:#f92672>=</span> count<span style=color:#f92672>.</span><span style=color:#a6e22e>getAndDecrement</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                notEmpty<span style=color:#f92672>.</span><span style=color:#a6e22e>signal</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            takeLock<span style=color:#f92672>.</span><span style=color:#a6e22e>unlock</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c <span style=color:#f92672>==</span> capacity<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            signalNotFull<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> x<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> E <span style=color:#a6e22e>take</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        E x<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> AtomicInteger count <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>count</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> ReentrantLock takeLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>takeLock</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        takeLock<span style=color:#f92672>.</span><span style=color:#a6e22e>lockInterruptibly</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 当取不到元素时候，就执行了await()方法，阻塞
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>count<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>()</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                notEmpty<span style=color:#f92672>.</span><span style=color:#a6e22e>await</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            x <span style=color:#f92672>=</span> dequeue<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            c <span style=color:#f92672>=</span> count<span style=color:#f92672>.</span><span style=color:#a6e22e>getAndDecrement</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                notEmpty<span style=color:#f92672>.</span><span style=color:#a6e22e>signal</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            takeLock<span style=color:#f92672>.</span><span style=color:#a6e22e>unlock</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c <span style=color:#f92672>==</span> capacity<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            signalNotFull<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> x<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>那么，take方法 notEmpty.await() 又是什么呢？跟上去，代码如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Condition notEmpty <span style=color:#f92672>=</span> takeLock<span style=color:#f92672>.</span><span style=color:#a6e22e>newCondition</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 那么，什么是Condition呢？我们继续看newCondition()
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 这个是在ReentrantLock类里的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> Condition <span style=color:#a6e22e>newCondition</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sync<span style=color:#f92672>.</span><span style=color:#a6e22e>newCondition</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> ConditionObject <span style=color:#a6e22e>newCondition</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> ConditionObject<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>await</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>interrupted</span><span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> InterruptedException<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            Node node <span style=color:#f92672>=</span> addConditionWaiter<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> savedState <span style=color:#f92672>=</span> fullyRelease<span style=color:#f92672>(</span>node<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> interruptMode <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> <span style=color:#f92672>(!</span>isOnSyncQueue<span style=color:#f92672>(</span>node<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                LockSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>park</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>interruptMode <span style=color:#f92672>=</span> checkInterruptWhileWaiting<span style=color:#f92672>(</span>node<span style=color:#f92672>))</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>acquireQueued<span style=color:#f92672>(</span>node<span style=color:#f92672>,</span> savedState<span style=color:#f92672>)</span> <span style=color:#f92672>&amp;&amp;</span> interruptMode <span style=color:#f92672>!=</span> THROW_IE<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                interruptMode <span style=color:#f92672>=</span> REINTERRUPT<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>node<span style=color:#f92672>.</span><span style=color:#a6e22e>nextWaiter</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#75715e>// clean up if cancelled
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                unlinkCancelledWaiters<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>interruptMode <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                reportInterruptAfterWait<span style=color:#f92672>(</span>interruptMode<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>至于这一大段 await 到底是什么意思，留个坑，以后再填吧，(我也不懂)。</p></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=/tags/arts/>arts</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>591 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2023-03-31 15:45</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/arts/week1031_share/><span class=button__icon>←</span>
<span class=button__text>Week1031_share</span></a></span>
<span class="button next"><a href=/posts/arts/week1032_algorithm/><span class=button__text>Week1032_algorithm</span>
<span class=button__icon>→</span></a></span></div></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.c90b8161416b87c69a8e02683b54ddd6edb90aea699648bf655e6cbc45b419b8e465d196e715772463dba35a6faf5decb2eb247480d38680484d54645b434570.js integrity="sha512-yQuBYUFrh8aajgJoO1Td1u25Cupplki/ZV5svEW0GbjkZdGW5xV3JGPbo1pvr13ssuskdIDThoBITVRkW0NFcA=="></script></body></html>