<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="Review - Java类加载机制 1. Introduction to Class Loaders Class loaders are responsible for loading Java classes dynamically to the JVM (Java Virtual Machine) during runtime. They&amp;rsquo;re also part of the JRE (Java Runtime Environment). Therefore, the JVM doesn&amp;rsquo;t need to know about the underlying files or file systems in order to run Java programs thanks to class loaders.
Furthermore, these Java classes aren&amp;rsquo;t loaded into memory all at once, but rather when they&amp;rsquo;re required by an application."><meta name=keywords content=",arts"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=/posts/arts/week1040_review/><title>Week1040_Review :: Hello Friend — A coder's Homepage</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css integrity="sha512-Cv93isQdFwaKBV+Z4X8kaVBYWHST58Xb/jVOcV9aRsGSArZsgAnFIhMpDoMDcFNoUtday1hdjn0nGp3+KZyyFw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/main.2a064c455b0ecbd6b1481b3bf9df2441e95838691022f40a5338c2cb1244f075.css integrity="sha256-KgZMRVsOy9axSBs7+d8kQelYOGkQIvQKUzjCyxJE8HU="><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Week1040_Review"><meta itemprop=description content="Review - Java类加载机制 1. Introduction to Class Loaders Class loaders are responsible for loading Java classes dynamically to the JVM (Java Virtual Machine) during runtime. They&rsquo;re also part of the JRE (Java Runtime Environment). Therefore, the JVM doesn&rsquo;t need to know about the underlying files or file systems in order to run Java programs thanks to class loaders.
Furthermore, these Java classes aren&rsquo;t loaded into memory all at once, but rather when they&rsquo;re required by an application."><meta itemprop=datePublished content="2023-03-31T15:45:48+00:00"><meta itemprop=dateModified content="2023-03-31T15:45:48+00:00"><meta itemprop=wordCount content="2604"><meta itemprop=keywords content="arts,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Week1040_Review"><meta name=twitter:description content="Review - Java类加载机制 1. Introduction to Class Loaders Class loaders are responsible for loading Java classes dynamically to the JVM (Java Virtual Machine) during runtime. They&rsquo;re also part of the JRE (Java Runtime Environment). Therefore, the JVM doesn&rsquo;t need to know about the underlying files or file systems in order to run Java programs thanks to class loaders.
Furthermore, these Java classes aren&rsquo;t loaded into memory all at once, but rather when they&rsquo;re required by an application."><meta property="og:title" content="Week1040_Review"><meta property="og:description" content="Review - Java类加载机制 1. Introduction to Class Loaders Class loaders are responsible for loading Java classes dynamically to the JVM (Java Virtual Machine) during runtime. They&rsquo;re also part of the JRE (Java Runtime Environment). Therefore, the JVM doesn&rsquo;t need to know about the underlying files or file systems in order to run Java programs thanks to class loaders.
Furthermore, these Java classes aren&rsquo;t loaded into memory all at once, but rather when they&rsquo;re required by an application."><meta property="og:type" content="article"><meta property="og:url" content="/posts/arts/week1040_review/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-31T15:45:48+00:00"><meta property="article:modified_time" content="2023-03-31T15:45:48+00:00"><meta property="og:site_name" content="Hello Friend "><meta property="article:published_time" content="2023-03-31 15:45:48 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>hello world...</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li><li><a href=/categorys>Category</a></li><li><a href=/series>Series</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>13 minutes</p></div><article><h1 class=post-title><a href=/posts/arts/week1040_review/>Week1040_Review</a></h1><div class=post-content><h2 id=review---java类加载机制httpswwwbaeldungcomjava-classloaders>Review - <a href=https://www.baeldung.com/java-classloaders>Java类加载机制</a></h2><blockquote><h2 id=1-introduction-to-class-loaders><strong>1. Introduction to Class Loaders</strong></h2><p>Class loaders are responsible for <strong>loading Java classes dynamically to the JVM</strong> <strong>(Java Virtual Machine) during runtime.</strong> They&rsquo;re also part of the JRE (Java Runtime Environment). Therefore, the JVM doesn&rsquo;t need to know about the underlying files or file systems in order to run Java programs thanks to class loaders.</p><p>Furthermore, these Java classes aren&rsquo;t loaded into memory all at once, but rather when they&rsquo;re required by an application. This is where class loaders come into the picture. They&rsquo;re responsible for loading classes into memory.</p><p>In this tutorial, we&rsquo;ll talk about different types of built-in class loaders and how they work. Then we&rsquo;ll introduce our own custom implementation.</p></blockquote><ol><li><p>介绍类加载器</p><p>类加载器是运行时用来动态加载Java类到JVM（Java虚拟机）。他们也是JRE（Java 运行时环境）的一部分。所以，由于有了类加载器，JVM为了运行Java程序就不需要知道底层的文件或者文件系统。</p><p>更深的是，这些Java类并不是一次全部加载到内存，而是当应用请求时候才加载。这是类加载器发挥作用的地方。他们职责是加载类到内存。</p><p>这个章节，我们讨论集中不同的内建类加载器是如何工作的。之后我们会介绍我们自定义实现。</p><h2 id=2-types-of-built-in-class-loaders><strong>2. Types of Built-in Class Loaders</strong></h2><p>Let&rsquo;s start by learning how we can load different classes using various class loaders:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.sun.javafx.util.Logging<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.ArrayList<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ClassLoaderTest</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printClassLoaders</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> ClassNotFoundException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Classloader of this class:&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> ClassLoaderTest<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>.</span><span style=color:#a6e22e>getClassLoader</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Classloader of Logging:&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> Logging<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>.</span><span style=color:#a6e22e>getClassLoader</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Classloader of ArrayList:&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> ArrayList<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>.</span><span style=color:#a6e22e>getClassLoader</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> ClassNotFoundException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        ClassLoaderTest loader <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ClassLoaderTest<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        loader<span style=color:#f92672>.</span><span style=color:#a6e22e>printClassLoaders</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><blockquote><p>As we can see, there are three different class loaders here: application, extension, and bootstrap (displayed as <em>null</em>).</p><p>The application class loader loads the class where the example method is contained. <strong>An application or system class loader loads our own files in the classpath.</strong></p><p>Next, the extension class loader loads the <em>Logging</em> class. <strong>Extension class loaders load classes that are an extension of the standard core Java classes.</strong></p><p>Finally, the bootstrap class loader loads the <em>ArrayList</em> class. <strong>A bootstrap or primordial class loader is the parent of all the others.</strong></p><p>However, we can see that for the <em>ArrayList,</em> it displays <em>null</em> in the output. <strong>This is because the bootstrap class loader is written in native code, not Java, so it doesn&rsquo;t show up as a Java class.</strong> As a result, the behavior of the bootstrap class loader will differ across JVMs.</p></blockquote><p>我们看到，有三种不同的类加载器： application, extension, 和bootstrap(这里显示null).</p><p>application 类加载器加载包含示例方法的类。一个application 或者system 类加载器加载我们自己的在classpath的文件。</p><p>Extensioni 类加载器加载 Logging 类。Extension类加载器加载标准Java库的类之外的那些扩展类。</p><p>Bootstrap类加再起加载ArrayList 类。一个bootstrap或者primordial类加载器是所有其他加载器的父亲。</p><p>然而，我们看到ArrayList ， 显示null. 这是应为bootstrap 类加载器使用本地代码写的，不是Java，所以不显示Java class. 因此，bootstrap 类加载器在不同JVM中表现是不同的。</p><blockquote><p>Now let&rsquo;s discuss each of these class loaders in more detail.</p><h3 id=21-bootstrap-class-loader><strong>2.1. Bootstrap Class Loader</strong></h3><p>Java classes are loaded by an instance of <em>java.lang.ClassLoader</em>. However, class loaders are classes themselves. So the question is, who loads the <em>java.lang.ClassLoader</em> itself*?*</p><p>This is where the bootstrap or primordial class loader comes into play.</p><p>It&rsquo;s mainly responsible for loading JDK internal classes, typically <em>rt.jar</em> and other core libraries located in the <em>$JAVA_HOME/jre/lib</em> directory. Additionally, the <strong>Bootstrap class loader serves as the parent of all the other *ClassLoader* instances</strong>.</p><p><strong>This bootstrap class loader is part of the core JVM and is written in native code,</strong> as pointed out in the above example. Different platforms might have different implementations of this particular class loader.</p></blockquote><p>Java类被一个java.lang.ClassLoader的实例加载。然而，类加载器是类自己，所以问题是，谁来加载 java.lang.ClassLoader 自身？</p><p>这就是bootstrap ，primoridial 类加载器发挥作用的地方。</p><p>主要职责是加载JDK内部的类，专门的 rt.jar 和其他核心库，在路径 $JAVA_HOME/jre/lib 目录</p><p>另外，bootstrap 类加载器服务作为所有其他 类加载器实例的父类.</p><p>这个bootstrap 类加载器是本地代码写的核心JVM的一部分， 如上个例子所述。不同平台可能对这个类加载器有不同的实现。</p><p>我的lib:</p><p>![image-20221108185208143](/Users/weiwang/Library/Application Support/typora-user-images/image-20221108185208143.png)</p><blockquote><h3 id=22-extension-class-loader><strong>2.2. Extension Class Loader</strong></h3><p>The <strong>extension class loader is a child of the bootstrap class loader, and takes care of loading the extensions of the standard core Java classes</strong> so that they&rsquo;re available to all applications running on the platform.</p><p>The extension class loader loads from the JDK extensions directory, usually the <em>$JAVA_HOME/lib/ext</em> directory, or any other directory mentioned in the <em>java.ext.dirs</em> system property.</p></blockquote><p>Extension 类加载器是bootstrap的孩子，关注加载Java标准核心类的扩展，所以就对按所有运行在平台上的 应用可用。</p><p>Extension 类加载器从 JDK 扩展目录加载， 通常是 $JAVA_HOME/lib/ext 目录 ， 或者其他java.ext.dirs系统属性提及到的其他目录</p><p>我的ext:</p><p><img src=https://tva1.sinaimg.cn/large/008vxvgGly1h7xx0nsdqij32ge04sjsa.jpg alt=image-20221108185258499></p><blockquote><h3 id=23-system-class-loader><strong>2.3. System Class Loader</strong></h3><p>The system or application class loader, on the other hand, takes care of loading all the application level classes into the JVM. <strong>It loads files found in the classpath environment variable, *-classpath,* or *-cp* command line option</strong>. It&rsquo;s also a child of the extensions class loader.</p></blockquote><p>system或application类加载器，换句话说，关心加载所有的应用级别类到JVM。 加载在classpath 环境变量 <em>-classpath,</em> 或者 *-cp* 命令行指定的路径。也是extension 类加载器的孩子。</p><blockquote><h2 id=3-how-do-class-loaders-work><strong>3. How Do Class Loaders Work?</strong></h2><p>Class loaders are part of the Java Runtime Environment. When the JVM requests a class, the class loader tries to locate the class and load the class definition into the runtime using the fully qualified class name.</p><p>The *<strong>java.lang.ClassLoader.loadClass()* method is responsible for loading the class definition into runtime</strong>. It tries to load the class based on a fully qualified name.</p><p>If the class isn&rsquo;t already loaded, it delegates the request to the parent class loader. This process happens recursively.</p><p>Eventually, if the parent class loader doesn’t find the class, then the child class will call the <em>java.net.URLClassLoader.findClass()</em> method to look for classes in the file system itself.</p><p>If the last child class loader isn&rsquo;t able to load the class either, it throws <a href=https://www.baeldung.com/java-classnotfoundexception-and-noclassdeffounderror><em>java.lang.NoClassDefFoundError</em> or <em>java.lang.ClassNotFoundException.</em></a></p></blockquote><p>类加载器是Java运行时环境的 一部分。当JVM请求一个类， 类加载器尝试定位类，使用全类名加载类定义到运行时。</p><p>Java.lang.ClassLoader.loadClass() 方法职责是加载类定义到运行时。它基于一个全路径名加载类。</p><p>如果类没有加载，就委派请求给父亲加载器。这个过程是递归的。</p><p>如果父亲加载器也没有发现类，然后子类将会调用java.net.URLClassLoader.findClass() 方法寻找类。</p><p>如果最后子类加载器也没有加载到类，就会抛出java.lang.NoClassDefFoundError 或者java.lang.ClassNotFoundException.</p><blockquote><p>Let&rsquo;s look at an example of the output when <em>ClassNotFoundException</em> is thrown:</p></blockquote><blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>java<span style=color:#f92672>.</span><span style=color:#a6e22e>lang</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ClassNotFoundException</span><span style=color:#f92672>:</span> com<span style=color:#f92672>.</span><span style=color:#a6e22e>baeldung</span><span style=color:#f92672>.</span><span style=color:#a6e22e>classloader</span><span style=color:#f92672>.</span><span style=color:#a6e22e>SampleClassLoader</span>    
</span></span><span style=display:flex><span>   at java<span style=color:#f92672>.</span><span style=color:#a6e22e>net</span><span style=color:#f92672>.</span><span style=color:#a6e22e>URLClassLoader</span><span style=color:#f92672>.</span><span style=color:#a6e22e>findClass</span><span style=color:#f92672>(</span>URLClassLoader<span style=color:#f92672>.</span><span style=color:#a6e22e>java</span><span style=color:#f92672>:</span><span style=color:#ae81ff>381</span><span style=color:#f92672>)</span>    
</span></span><span style=display:flex><span>   at java<span style=color:#f92672>.</span><span style=color:#a6e22e>lang</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ClassLoader</span><span style=color:#f92672>.</span><span style=color:#a6e22e>loadClass</span><span style=color:#f92672>(</span>ClassLoader<span style=color:#f92672>.</span><span style=color:#a6e22e>java</span><span style=color:#f92672>:</span><span style=color:#ae81ff>424</span><span style=color:#f92672>)</span>    
</span></span><span style=display:flex><span>   at java<span style=color:#f92672>.</span><span style=color:#a6e22e>lang</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ClassLoader</span><span style=color:#f92672>.</span><span style=color:#a6e22e>loadClass</span><span style=color:#f92672>(</span>ClassLoader<span style=color:#f92672>.</span><span style=color:#a6e22e>java</span><span style=color:#f92672>:</span><span style=color:#ae81ff>357</span><span style=color:#f92672>)</span>    
</span></span><span style=display:flex><span>   at java<span style=color:#f92672>.</span><span style=color:#a6e22e>lang</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Class</span><span style=color:#f92672>.</span><span style=color:#a6e22e>forName0</span><span style=color:#f92672>(</span>Native Method<span style=color:#f92672>)</span>    
</span></span><span style=display:flex><span>   at java<span style=color:#f92672>.</span><span style=color:#a6e22e>lang</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Class</span><span style=color:#f92672>.</span><span style=color:#a6e22e>forName</span><span style=color:#f92672>(</span>Class<span style=color:#f92672>.</span><span style=color:#a6e22e>java</span><span style=color:#f92672>:</span><span style=color:#ae81ff>348</span><span style=color:#f92672>)</span>
</span></span></code></pre></div></blockquote></li></ol><p>看一个例子。</p><blockquote><p>If we go through the sequence of events right from calling <em>java.lang.Class.forName()</em>, we can see that it first tries to load the class through the parent class loader, and then <em>java.net.URLClassLoader.findClass()</em> to look for the class itself.</p><p>When it still doesn&rsquo;t find the class, it throws a <em>ClassNotFoundException.</em></p><p>Now let&rsquo;s examine three important features of class loaders.</p></blockquote><p>如果我们通过序列事件调用java.lang.Class.forName()， 我们可以看到首先尝试加载class 通过父亲类加载器，之后它自己尝试java.net.URLClassLoader.findClass() 来找类。</p><p>当也找不到Class，就会抛出ClassNotFoundExceptioni.</p><p>现在来考察类加载器的三个重要特性</p><blockquote><h3 id=31-delegation-model><strong>3.1. Delegation Model</strong></h3><p>Class loaders follow the delegation model, where <strong>on request to find a class or resource, a *ClassLoader* instance will delegate the search of the class or resource to the parent class loader</strong>.</p><p>Let&rsquo;s say we have a request to load an application class into the JVM. The system class loader first delegates the loading of that class to its parent extension class loader, which in turn delegates it to the bootstrap class loader.</p><p>Only if the bootstrap and then the extension class loader are unsuccessful in loading the class, the system class loader tries to load the class itself.</p></blockquote><p>委派模型</p><p>类加载器遵从的模型，当请求找一个类或者资源， 一个 类加载器实例将会委派给父加载器来找类或资源。</p><p>我们有一个请求需要加载应用class到JVM。system类加载器委派它的父亲 extension 加载器来加载类，然后它委托给bootstrap加载器。</p><p>当仅当bootstrap 和之后的 extension类加载没有加载到类，sysytem类加载器才会自己尝试加载类。</p><blockquote><h3 id=32-unique-classes><strong>3.2. Unique Classes</strong></h3><p>As a consequence of the delegation model, it&rsquo;s easy to ensure <strong>unique classes, as we always try to delegate upwards</strong>.</p><p>If the parent class loader isn&rsquo;t able to find the class, only then will the current instance attempt to do so itself.</p></blockquote><p>唯一类。</p><p>作为一个委派模型结果，很容易确保唯一类，因为总是尝试向上委派。</p><p>如果父加载器没找到类，当前实例才会自己去加载。</p><blockquote><h3 id=33-visibility><strong>3.3. Visibility</strong></h3><p>In addition, <strong>children class loaders are visible to classes loaded by their parent class loaders</strong>.</p><p>For instance, classes loaded by the system class loader have visibility into classes loaded by the extension and bootstrap class loaders, but not vice-versa.</p><p>To illustrate this, if Class A is loaded by the application class loader, and class B is loaded by the extensions class loader, then both A and B classes are visible as far as other classes loaded by the application class loader are concerned.</p><p>Class B, however, is the only class visible to other classes loaded by the extension class loader.</p></blockquote><p>可见性。</p><p>更多的是，子加载器对父加载器加载的类是可见的。</p><p>例如，被system加载器加载的类对 extension和bootstrap加载器加载的类具有可见性，反之不然。</p><p>为了解释这一点，如果 Class A 被 application 加载器加载，class B 被extensions 加载，那么 A和B类都对 application 加载器加载的类可见。</p><p>Class B, 却只能被extension 加载的类可见。</p><blockquote><h2 id=4-custom-classloader><strong>4. Custom ClassLoader</strong></h2><p>The built-in class loader is sufficient for most cases where the files are already in the file system.</p><p>However, in scenarios where we need to load classes out of the local hard drive or a network, we may need to make use of custom class loaders.</p><p>In this section, we&rsquo;ll cover some other use cases for custom class loaders and demonstrate how to create one.</p></blockquote><p>自定义加载器</p><p>内建加载器对大多数已经在文件系统中的文件是足够了。</p><p>然而，我们还需要加载本地硬件或者网络之外的的类，我们可能需要使用自定义加载器。</p><blockquote><h3 id=41-custom-class-loaders-use-cases>4.1. Custom Class Loaders Use-Cases</h3><p>Custom class loaders are helpful for more than just loading the class during runtime. A few use cases might include:</p><ol><li>Helping to modify the existing bytecode, e.g. weaving agents</li><li>Creating classes dynamically suited to the user&rsquo;s needs, e.g. in JDBC, switching between different driver implementations is done through dynamic class loading.</li><li>Implementing a class versioning mechanism while loading different bytecodes for classes with the same names and packages. This can be done either through a URL class loader (load jars via URLs) or custom class loaders.</li></ol><p>Below are more concrete examples where custom class loaders might come in handy.</p><p><strong>Browsers, for instance, use a custom class loader to load executable content from a website.</strong> A browser can load applets from different web pages using separate class loaders. The applet viewer, which is used to run applets, contains a <em>ClassLoader</em> that accesses a website on a remote server instead of looking in the local file system.</p><p>It then loads the raw bytecode files via HTTP, and turns them into classes inside the JVM. Even if these <strong>applets have the same name, they&rsquo;re considered different components if loaded by different class loaders</strong>.</p><p>Now that we understand why custom class loaders are relevant, let&rsquo;s implement a subclass of <em>ClassLoader</em> to extend and summarise the functionality of how the JVM loads classes.</p></blockquote><p>自定义类加载器用例</p><p>自定义类加载器对于不仅在运行时加载类是很有帮助的。一些用例可能包括：</p><ol><li>帮助改已经存在的字节码，例如编织代理</li><li>动态创建类来适应用户所需，例如在JDBC，切换不同的驱动就是通过动态加载类来实现的。</li><li>在为具有相同名称和软件包的类加载不同的字节码时，实现类版本控制机制。这可以通过URL 类加载器(通过URL来加载jar) 或者自定义类加载器。</li></ol><p>底下是更确切的例子，自定义类加载器场景，</p><p>浏览器，实际上，使用一个定义加载器从网站上加载可执行内容。一个浏览器可以加载 applets 从不同的网页通过使用不同的类加载器。applet viewer, 用来跑applets, 包括一个类加载器操作远端服务器，而不是找本地文件系统。</p><p>之后通过HTTP加载未加工的字节码文件，在JVM内部转化成class. 尽管这些applets 有相同的名字，但是如果通过不同的类加载器加载，就被认为是不同组件。</p><p>现在我们理解了为什么自定义加载器是有意义的，我们实现一个ClassLoader的子类来扩展总结JVM是如何加载class的。</p><blockquote><h3 id=42-creating-our-custom-class-loader>4.2. Creating Our Custom Class Loader</h3><p>For illustration purposes, let&rsquo;s say we need to load classes from a file using a custom class loader.</p><p><strong>We need to extend the *ClassLoader* class and override the *findClass()* method:</strong></p></blockquote><p>需要继承ClassLoader 类，重写findClass方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.io.*<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CustomClassLoader</span> <span style=color:#66d9ef>extends</span> ClassLoader<span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Class<span style=color:#f92672>&lt;?&gt;</span> findClass<span style=color:#f92672>(</span>String name<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> ClassNotFoundException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//        return super.findClass(name);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> b <span style=color:#f92672>=</span> loadClassFromFile<span style=color:#f92672>(</span>name<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> defineClass<span style=color:#f92672>(</span>name<span style=color:#f92672>,</span> b<span style=color:#f92672>,</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>,</span> b<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>loadClassFromFile</span><span style=color:#f92672>(</span>String fileName<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        InputStream inputStream <span style=color:#f92672>=</span> getClass<span style=color:#f92672>().</span><span style=color:#a6e22e>getClassLoader</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getResourceAsStream</span><span style=color:#f92672>(</span>fileName<span style=color:#f92672>.</span><span style=color:#a6e22e>replace</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#39;.&#39;</span><span style=color:#f92672>,</span> File<span style=color:#f92672>.</span><span style=color:#a6e22e>separatorChar</span><span style=color:#f92672>)</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;.class&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> buffer<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        ByteArrayOutputStream byteStream <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ByteArrayOutputStream<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> nextValue <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> <span style=color:#f92672>((</span>nextValue <span style=color:#f92672>=</span> inputStream<span style=color:#f92672>.</span><span style=color:#a6e22e>read</span><span style=color:#f92672>())</span> <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                byteStream<span style=color:#f92672>.</span><span style=color:#a6e22e>write</span><span style=color:#f92672>(</span>nextValue<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IOException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        buffer <span style=color:#f92672>=</span> byteStream<span style=color:#f92672>.</span><span style=color:#a6e22e>toByteArray</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> buffer<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><blockquote><p>In the above example, we defined a custom class loader that extends the default class loader, and loads a byte array from the specified file.</p></blockquote><p>上面例子，我们定义了一个自定义类加载器继承默认类加载器，加载字节数组从特定的文件。</p><blockquote><h3 id=5-understanding-javalangclassloader>5. Understanding <em>java.lang.ClassLoader</em></h3><p>Let&rsquo;s discuss a few essential methods from the <em>java.lang.ClassLoader</em> class to get a clearer picture of how it works.</p><h3 id=51-the-loadclass-method>5.1. The <em>loadClass()</em> Method</h3></blockquote><p>理解java.lang.ClassLoader</p><p>我们讨论一些java.lang.ClassLoader的必要方法来更清楚它是如何工作的。</p><p><code>public Class&lt;?> loadClass(String name, boolean resolve) throws ClassNotFoundException {</code></p><blockquote><p>This method is responsible for loading the class given a name parameter. The name parameter refers to the fully qualified class name.</p><p>The Java Virtual Machine invokes the <em>loadClass()</em> method to resolve class references, setting resolve to <em>true</em>. However, it isn&rsquo;t always necessary to resolve a class. <strong>If we only need to determine if the class exists or not, then the resolve parameter is set to *false*.</strong></p><p>This method serves as an entry point for the class loader.</p><p>We can try to understand the internal working of the <em>loadClass()</em> method from the source code of <em>java.lang.ClassLoader:</em></p></blockquote><p>这个方法职责是根据name 参数来加载类。 name参数代表符合条件的类名字。</p><p>Java虚拟机调用 loadClass() 方法来解析类引用，设置resolve为true。 然而，它并非每次都需要解析一个类。如果我们仅仅需要确定类是否存在，resolve参数设置为 false.</p><p>这个方法充当类加载器的入口点。</p><p>我们可以从 java.lang.ClassLoader的源码来理解内部工作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> Class<span style=color:#f92672>&lt;?&gt;</span> loadClass<span style=color:#f92672>(</span>String name<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span> resolve<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>throws</span> ClassNotFoundException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>getClassLoadingLock<span style=color:#f92672>(</span>name<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// First, check if the class has already been loaded
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Class<span style=color:#f92672>&lt;?&gt;</span> c <span style=color:#f92672>=</span> findLoadedClass<span style=color:#f92672>(</span>name<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>long</span> t0 <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>parent <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        c <span style=color:#f92672>=</span> parent<span style=color:#f92672>.</span><span style=color:#a6e22e>loadClass</span><span style=color:#f92672>(</span>name<span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        c <span style=color:#f92672>=</span> findBootstrapClassOrNull<span style=color:#f92672>(</span>name<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>ClassNotFoundException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// ClassNotFoundException thrown if class not found
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// from the non-null parent class loader
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// If still not found, then invoke findClass in order
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// to find the class.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    c <span style=color:#f92672>=</span> findClass<span style=color:#f92672>(</span>name<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>resolve<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                resolveClass<span style=color:#f92672>(</span>c<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> c<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><blockquote><p>The default implementation of the method searches for classes in the following order:</p><ol><li>Invokes the <em>findLoadedClass(String)</em> method to see if the class is already loaded.</li><li>Invokes the <em>loadClass(String)</em> method on the parent class loader.</li><li>Invoke the <em>findClass(String)</em> method to find the class.</li></ol></blockquote><p>搜索类方法的默认实现是如下顺序：</p><ol><li>调用 findLoaderClass(String) 方法可按是否已经加载</li><li>调用 父加载器的 loadClass(String) 方法</li><li>调用 findClass(String)来查找</li></ol><blockquote><h3 id=52-the-defineclass-method>5.2. The <em>defineClass()</em> Method</h3></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> Class<span style=color:#f92672>&lt;?&gt;</span> defineClass<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>  String name<span style=color:#f92672>,</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> b<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> off<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> len<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> ClassFormatError
</span></span></code></pre></div><blockquote><p>This method is responsible for the conversion of an array of bytes into an instance of a class. Before we use the class, we need to resolve it.</p><p>If the data doesn&rsquo;t contain a valid class, it throws a <em>ClassFormatError.</em></p><p>Also, we can&rsquo;t override this method, since it&rsquo;s marked as final.</p></blockquote><p>这方法只是是转换一个字节数组为一个类实例。我们用类之前，我们需要调用它。</p><p>如果数据不包括一个合法的类，就会抛出 ClassFormatError</p><p>我们不能覆盖这个方法，因为它被标记为 final.</p><blockquote><h3 id=53-the-findclass-method>5.3. The <em>findClass()</em> Method</h3></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> Class<span style=color:#f92672>&lt;?&gt;</span> findClass<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>  String name<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> ClassNotFoundException
</span></span></code></pre></div><blockquote><p>This method finds the class with the fully qualified name as a parameter. We need to override this method in custom class loader implementations that follow the delegation model for loading classes.</p><p>In addition, <em>loadClass()</em> invokes this method if the parent class loader can&rsquo;t find the requested class.</p><p>The default implementation throws a <em>ClassNotFoundException</em> if no parent of the class loader finds the class.</p></blockquote><p>这个方法根据全路径名称来找类。我们需要覆盖它在自定义类加载器实现里，遵从加载类的委派模型。</p><p>另外，loadClass 调用这方法当父类加载器没有找到请求的类时候。</p><p>默认实现抛出一个 ClassNotFoundException 如果父亲加载器没有找到类。</p><blockquote><h3 id=54-the-getparent-method>5.4. The <em>getParent()</em> Method</h3></blockquote><p><code>public final ClassLoader getParent()</code></p><blockquote><p>This method returns the parent class loader for delegation.</p><p>Some implementations, like the one seen before in Section 2, use <em>null</em> to represent the bootstrap class loader.</p></blockquote><p>这个方法返回委派的父加载器。</p><p>有些实现，使用null来代表bootstrap类加载器。</p><blockquote><h3 id=55-the-getresource-method>5.5. The <em>getResource()</em> Method</h3></blockquote><p><code>public URL getResource(String name)</code></p><blockquote><p>This method tries to find a resource with the given name.</p><p>It will first delegate to the parent class loader for the resource. <strong>If the parent is *null*, the path of the class loader built into the virtual machine is searched.</strong></p><p>If that fails, then the method will invoke <em>findResource(String)</em> to find the resource. The resource name specified as an input can be relative or absolute to the classpath.</p><p>It returns an URL object for reading the resource, or null if the resource can&rsquo;t be found or the invoker doesn&rsquo;t have adequate privileges to return the resource.</p><p>It&rsquo;s important to note that Java loads resources from the classpath.</p><p>Finally, <strong>resource loading in Java is considered location-independent,</strong> as it doesn&rsquo;t matter where the code is running as long as the environment is set to find the resources.</p></blockquote><p>这个方法尝试根据给定名字来找资源。</p><p>首先会委派父加载器去找资源。如果 父亲是 null, 虚拟机内建的类加载器路径就找到了。</p><p>如果失败，方法会调用 findResource(String)来找资源。资源名字明确作为一个输入，可以是相对或绝对路径。</p><p>返回一个URL对象来读资源，或者资源找不到或调用者没有权限，就返回null。</p><p>留意到Java加载资源从classpath 是很重要的。</p><p>最后，Java中的资源加载被认为是位置无关的，因为只要将环境设置为查找资源，代码在哪里运行并不重要。</p><blockquote><h2 id=6-context-classloaders>6. Context Classloaders</h2><p>In general, context class loaders provide an alternative method to the class-loading delegation scheme introduced in J2SE.</p><p>Like we learned before, <strong>classloaders in a JVM follow a hierarchical model, such that every class loader has a single parent with the exception of the bootstrap class loader.</strong></p><p>However, sometimes when JVM core classes need to dynamically load classes or resources provided by application developers, we might encounter a problem.</p><p>For example, in JNDI, the core functionality is implemented by the bootstrap classes in <em>rt.jar.</em> But these JNDI classes may load JNDI providers implemented by independent vendors (deployed in the application classpath). This scenario calls for the bootstrap class loader (parent class loader) to load a class visible to the application loader (child class loader).</p><p><strong>J2SE delegation doesn&rsquo;t work here, and to get around this problem, we need to find alternative ways of class loading. This can be achieved using thread context loaders.</strong></p><p>The <em>java.lang.Thread</em> class has a method, *<strong>getContextClassLoader(),* that returns the *ContextClassLoader* for the particular thread</strong>. The <em>ContextClassLoader</em> is provided by the creator of the thread when loading resources and classes.</p><p>If the value isn&rsquo;t set, then it defaults to the class loader context of the parent thread.</p></blockquote><p>上下文类加载器</p><p>通常，context 类加载器提供一个可供选择的方法给 类加载委派语法 使用J2SE.</p><p>就像我们之前了解的， 类加载器器在JVM中遵从一个竖向的模型，每个类加载器有一个单独的父亲除了 bootstrap 类加载器。</p><p>然而，有时应用开发者需要JVM核心类动态加载类或者资源，我们可能会遇到问题。</p><p>例如， 在JNDI， 核心方法是在rt.jar 的bootstrap 类实现的 。但是这些JDNI 类可能加载 JDNI提供者实现通过独立的 vendors(部署在应用 类路径)。此场景调用bootstrap类加载器(父类加载器)加载 application加载器(子加载器)可见的类。</p><p>J2SE委派在这里不工作，围绕这个问题，我们需要寻找类加载的替代方法。这可以使用线程context加载器来实现。</p><p>java.lang.Thread 类有一个方法， getContextClassLoader() ， 返回 ContextClassLoader 为特定线程。 ContextClassLoader 是线程创建者提供的当加载资源和类时候。</p><p>如果值没有设置，默认使用付线程的类加载器上下文。</p><blockquote><h2 id=7-conclusion><strong>7. Conclusion</strong></h2><p>Class loaders are essential to execute a Java program. In this article, we provided a good introduction to them.</p><p>We discussed the different types of class loaders, namely Bootstrap, Extensions, and System class loaders. Bootstrap serves as a parent for all of them, and is responsible for loading the JDK internal classes. Extensions and system, on the other hand, load classes from the Java extensions directory and classpath, respectively.</p><p>We also learned how class loaders work and examined some features, such as delegation, visibility, and uniqueness. Then we briefly explained how to create a custom class loader. Finally, we provided an introduction to Context class loaders.</p><p>As always, the source code for these examples can be found <a href=https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-jvm>over on GitHub</a>.</p></blockquote><p>总结</p><p>类加载器是执行Java程序的要点。这篇文章，我们提供了好的介绍。</p><p>我们讨论了不同类型的类加载器，叫 Bootstrap, Extension,和system 类加载器。 Bootstrap服务为所有的父类加载器，职责是加载JDK内部类。另一方面，扩展和系统分别从Java扩展目录和类路径加载类。</p><p>我们也学到了类加载器如何工作，检查了一些特性，例如委派，可见性和不重复行。之后解释了创建一个自定义加载器。最后，我们提供了介绍Context 类加载器。</p></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=/tags/arts/>arts</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>2604 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2023-03-31 15:45</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/arts/week1040_algorithm/><span class=button__icon>←</span>
<span class=button__text>Week1040_Algorithm</span></a></span>
<span class="button next"><a href=/posts/arts/week1040_share/><span class=button__text>Week1040_Share</span>
<span class=button__icon>→</span></a></span></div></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.c90b8161416b87c69a8e02683b54ddd6edb90aea699648bf655e6cbc45b419b8e465d196e715772463dba35a6faf5decb2eb247480d38680484d54645b434570.js integrity="sha512-yQuBYUFrh8aajgJoO1Td1u25Cupplki/ZV5svEW0GbjkZdGW5xV3JGPbo1pvr13ssuskdIDThoBITVRkW0NFcA=="></script></body></html>