<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="Java 内存区域及对象 计算机存储单位 从小到大 Bit byte KB MB GB TB
计算机存储元件
寄存器 CPU读写数据存储元件 内核空间与用户空间 字长 CPU一次能并行处理二进制的位数 堆栈 堆用来存储对象，栈用来执行程序
运行时数据区域
线程独有的内存区域 a. Program counter register 程序计数器 当前线程执行的字节码行号指示器 b. Java Stack 虚拟机栈 生命周期和线程相同。每个方法执行时候都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接、方法出口等信息，每个方法从调用到执行的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小通常与虚拟机实现有关，通常在256K-756K之间。 c. Native Method stack 本地方法栈 和虚拟机栈作用一样，方法栈为虚拟机使用的本地方法服务。
线程间共享的内存区域 a. heap ,堆 存放对象实例。细分为新生代和老年代。 b. Method Area 方法区 存储虚拟机加载的类信息，常亮、静态变量、即时编译器编译后的代码等数据。 c. Runtime Constant Pool 运行时常量池 类的方法、字段、接口库等描述信息 + 编译期产生的各种字面量和符号引用
直接内存
对象创建 语言层面，new, 虚拟机层面
虚拟机遇到new指令，首先去检查这个指令的参数能否在常亮池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有就进行类的初始化过程。
类加载检查通过后，为新生对象分配内存，过程中，
a. 若内存规整，指针碰撞法分配内存。 意思是所有已用内存在一边，空闲在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式 b. 如果内存不规整，虚拟机使用空闲列表法来分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。如果垃圾收集器选择的是CMS这种基于标记-清除算法的，虚拟机采用这种分配方式。 另外一个问题及时保证new对象时候的线程安全性。因为可能出现虚拟机正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。虚拟机采用了CAS配上失败重试的方式保证更新更新操作的原子性和TLAB两种方式来解决这个问题。
内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。
对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。
执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。"><meta name=keywords content=",arts"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=/posts/arts/week1002_share/><title>Week1002_share :: Hello Friend — A coder's Homepage</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css integrity="sha512-Cv93isQdFwaKBV+Z4X8kaVBYWHST58Xb/jVOcV9aRsGSArZsgAnFIhMpDoMDcFNoUtday1hdjn0nGp3+KZyyFw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/main.2a064c455b0ecbd6b1481b3bf9df2441e95838691022f40a5338c2cb1244f075.css integrity="sha256-KgZMRVsOy9axSBs7+d8kQelYOGkQIvQKUzjCyxJE8HU="><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Week1002_share"><meta itemprop=description content="Java 内存区域及对象 计算机存储单位 从小到大 Bit byte KB MB GB TB
计算机存储元件
寄存器 CPU读写数据存储元件 内核空间与用户空间 字长 CPU一次能并行处理二进制的位数 堆栈 堆用来存储对象，栈用来执行程序
运行时数据区域
线程独有的内存区域 a. Program counter register 程序计数器 当前线程执行的字节码行号指示器 b. Java Stack 虚拟机栈 生命周期和线程相同。每个方法执行时候都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接、方法出口等信息，每个方法从调用到执行的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小通常与虚拟机实现有关，通常在256K-756K之间。 c. Native Method stack 本地方法栈 和虚拟机栈作用一样，方法栈为虚拟机使用的本地方法服务。
线程间共享的内存区域 a. heap ,堆 存放对象实例。细分为新生代和老年代。 b. Method Area 方法区 存储虚拟机加载的类信息，常亮、静态变量、即时编译器编译后的代码等数据。 c. Runtime Constant Pool 运行时常量池 类的方法、字段、接口库等描述信息 + 编译期产生的各种字面量和符号引用
直接内存
对象创建 语言层面，new, 虚拟机层面
虚拟机遇到new指令，首先去检查这个指令的参数能否在常亮池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有就进行类的初始化过程。
类加载检查通过后，为新生对象分配内存，过程中，
a. 若内存规整，指针碰撞法分配内存。 意思是所有已用内存在一边，空闲在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式 b. 如果内存不规整，虚拟机使用空闲列表法来分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。如果垃圾收集器选择的是CMS这种基于标记-清除算法的，虚拟机采用这种分配方式。 另外一个问题及时保证new对象时候的线程安全性。因为可能出现虚拟机正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。虚拟机采用了CAS配上失败重试的方式保证更新更新操作的原子性和TLAB两种方式来解决这个问题。
内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。
对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。
执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。"><meta itemprop=datePublished content="2023-03-31T15:45:31+00:00"><meta itemprop=dateModified content="2023-03-31T15:45:31+00:00"><meta itemprop=wordCount content="89"><meta itemprop=keywords content="arts,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Week1002_share"><meta name=twitter:description content="Java 内存区域及对象 计算机存储单位 从小到大 Bit byte KB MB GB TB
计算机存储元件
寄存器 CPU读写数据存储元件 内核空间与用户空间 字长 CPU一次能并行处理二进制的位数 堆栈 堆用来存储对象，栈用来执行程序
运行时数据区域
线程独有的内存区域 a. Program counter register 程序计数器 当前线程执行的字节码行号指示器 b. Java Stack 虚拟机栈 生命周期和线程相同。每个方法执行时候都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接、方法出口等信息，每个方法从调用到执行的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小通常与虚拟机实现有关，通常在256K-756K之间。 c. Native Method stack 本地方法栈 和虚拟机栈作用一样，方法栈为虚拟机使用的本地方法服务。
线程间共享的内存区域 a. heap ,堆 存放对象实例。细分为新生代和老年代。 b. Method Area 方法区 存储虚拟机加载的类信息，常亮、静态变量、即时编译器编译后的代码等数据。 c. Runtime Constant Pool 运行时常量池 类的方法、字段、接口库等描述信息 + 编译期产生的各种字面量和符号引用
直接内存
对象创建 语言层面，new, 虚拟机层面
虚拟机遇到new指令，首先去检查这个指令的参数能否在常亮池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有就进行类的初始化过程。
类加载检查通过后，为新生对象分配内存，过程中，
a. 若内存规整，指针碰撞法分配内存。 意思是所有已用内存在一边，空闲在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式 b. 如果内存不规整，虚拟机使用空闲列表法来分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。如果垃圾收集器选择的是CMS这种基于标记-清除算法的，虚拟机采用这种分配方式。 另外一个问题及时保证new对象时候的线程安全性。因为可能出现虚拟机正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。虚拟机采用了CAS配上失败重试的方式保证更新更新操作的原子性和TLAB两种方式来解决这个问题。
内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。
对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。
执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。"><meta property="og:title" content="Week1002_share"><meta property="og:description" content="Java 内存区域及对象 计算机存储单位 从小到大 Bit byte KB MB GB TB
计算机存储元件
寄存器 CPU读写数据存储元件 内核空间与用户空间 字长 CPU一次能并行处理二进制的位数 堆栈 堆用来存储对象，栈用来执行程序
运行时数据区域
线程独有的内存区域 a. Program counter register 程序计数器 当前线程执行的字节码行号指示器 b. Java Stack 虚拟机栈 生命周期和线程相同。每个方法执行时候都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接、方法出口等信息，每个方法从调用到执行的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小通常与虚拟机实现有关，通常在256K-756K之间。 c. Native Method stack 本地方法栈 和虚拟机栈作用一样，方法栈为虚拟机使用的本地方法服务。
线程间共享的内存区域 a. heap ,堆 存放对象实例。细分为新生代和老年代。 b. Method Area 方法区 存储虚拟机加载的类信息，常亮、静态变量、即时编译器编译后的代码等数据。 c. Runtime Constant Pool 运行时常量池 类的方法、字段、接口库等描述信息 + 编译期产生的各种字面量和符号引用
直接内存
对象创建 语言层面，new, 虚拟机层面
虚拟机遇到new指令，首先去检查这个指令的参数能否在常亮池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有就进行类的初始化过程。
类加载检查通过后，为新生对象分配内存，过程中，
a. 若内存规整，指针碰撞法分配内存。 意思是所有已用内存在一边，空闲在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式 b. 如果内存不规整，虚拟机使用空闲列表法来分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。如果垃圾收集器选择的是CMS这种基于标记-清除算法的，虚拟机采用这种分配方式。 另外一个问题及时保证new对象时候的线程安全性。因为可能出现虚拟机正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。虚拟机采用了CAS配上失败重试的方式保证更新更新操作的原子性和TLAB两种方式来解决这个问题。
内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。
对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。
执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。"><meta property="og:type" content="article"><meta property="og:url" content="/posts/arts/week1002_share/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-31T15:45:31+00:00"><meta property="article:modified_time" content="2023-03-31T15:45:31+00:00"><meta property="og:site_name" content="Hello Friend "><meta property="article:published_time" content="2023-03-31 15:45:31 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>hello world...</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li><li><a href=/categorys>Category</a></li><li><a href=/series>Series</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>One minute</p></div><article><h1 class=post-title><a href=/posts/arts/week1002_share/>Week1002_share</a></h1><div class=post-content><h2 id=java-内存区域及对象>Java 内存区域及对象</h2><ol><li><p>计算机存储单位
从小到大 Bit byte KB MB GB TB</p></li><li><p>计算机存储元件</p><ul><li>寄存器 CPU读写数据存储元件</li><li>内核空间与用户空间</li><li>字长 CPU一次能并行处理二进制的位数</li></ul></li><li><p>堆栈
堆用来存储对象，栈用来执行程序</p></li><li><p>运行时数据区域</p><p><img src=http://images.blogjava.net/blogjava_net/nkjava/jvmstructure.png alt=JVM内存区域></p><ol><li><p>线程独有的内存区域
a. Program counter register 程序计数器
当前线程执行的字节码行号指示器
b. Java Stack 虚拟机栈
生命周期和线程相同。每个方法执行时候都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接、方法出口等信息，每个方法从调用到执行的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小通常与虚拟机实现有关，通常在256K-756K之间。
c. Native Method stack 本地方法栈
和虚拟机栈作用一样，方法栈为虚拟机使用的本地方法服务。</p></li><li><p>线程间共享的内存区域
a. heap ,堆
存放对象实例。细分为新生代和老年代。
b. Method Area 方法区
存储虚拟机加载的类信息，常亮、静态变量、即时编译器编译后的代码等数据。
c. Runtime Constant Pool 运行时常量池
类的方法、字段、接口库等描述信息 + 编译期产生的各种字面量和符号引用</p></li><li><p>直接内存</p></li></ol></li></ol><h3 id=对象创建>对象创建</h3><p>语言层面，new, 虚拟机层面</p><ol><li><p>虚拟机遇到new指令，首先去检查这个指令的参数能否在常亮池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有就进行类的初始化过程。</p></li><li><p>类加载检查通过后，为新生对象分配内存，过程中，</p><ul><li>a. 若内存规整，指针碰撞法分配内存。 意思是所有已用内存在一边，空闲在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式</li><li>b. 如果内存不规整，虚拟机使用空闲列表法来分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。如果垃圾收集器选择的是CMS这种基于标记-清除算法的，虚拟机采用这种分配方式。</li></ul><p>另外一个问题及时保证new对象时候的线程安全性。因为可能出现虚拟机正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。虚拟机采用了CAS配上失败重试的方式保证更新更新操作的原子性和TLAB两种方式来解决这个问题。</p></li><li><p>内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</p></li><li><p>对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。</p></li><li><p>执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p></li></ol><h3 id=对象定位方式>对象定位方式</h3><p>建立对象是为了使用对象，Java程序需要通过栈上reference数据来操作堆上具体对象。</p><pre tabindex=0><code>Object obj = new Object();
</code></pre><p>new Object() 后有两部分内容，一部分是类数据（比如代表类的Class对象）、一部分是实例数据</p><p>由于reference 在Java虚拟机规范中这是一个指向对象的new Object() 的引用obj,并没有规定obj
应该通过何种方式去定位、访问堆中对象的具体位置，所以对象访问方式是取决于虚拟机实现而定的。主流方式有两种：</p><ol><li>句柄访问。Java堆中划分出一块句柄池，obj指向的是对象的句柄地址，句柄则包含了类数据的地址和实例数据的地址</li><li>指针访问。对象中存储所有的实例数据和类数据的地址，obj指向的是这个对象</li></ol><p>Hotspot 虚拟机采用的后者。</p></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=/tags/arts/>arts</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>89 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2023-03-31 15:45</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/arts/week1006_tip/><span class=button__icon>←</span>
<span class=button__text>Week1006_tip</span></a></span>
<span class="button next"><a href=/posts/arts/week1003_algorthm/><span class=button__text>Week1003_algorthm</span>
<span class=button__icon>→</span></a></span></div></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.c90b8161416b87c69a8e02683b54ddd6edb90aea699648bf655e6cbc45b419b8e465d196e715772463dba35a6faf5decb2eb247480d38680484d54645b434570.js integrity="sha512-yQuBYUFrh8aajgJoO1Td1u25Cupplki/ZV5svEW0GbjkZdGW5xV3JGPbo1pvr13ssuskdIDThoBITVRkW0NFcA=="></script></body></html>